
<hr />
<p>layout: post
title: 第四章 正则表达式的匹配原理
categories: 文本编辑
tag：正则表达式
—</p>

<ul id="markdown-toc">
  <li><a href="#正则引擎的分类" id="markdown-toc-正则引擎的分类">正则引擎的分类</a></li>
  <li><a href="#匹配的基础" id="markdown-toc-匹配的基础">匹配的基础</a>    <ul>
      <li><a href="#规则1优先选择最左端的匹配结果" id="markdown-toc-规则1优先选择最左端的匹配结果">规则1：优先选择最左端的匹配结果</a></li>
      <li><a href="#规则2-标准量词是匹配优先" id="markdown-toc-规则2-标准量词是匹配优先">规则2: 标准量词是匹配优先</a></li>
    </ul>
  </li>
  <li><a href="#表达式主导与文本主导" id="markdown-toc-表达式主导与文本主导">表达式主导与文本主导</a>    <ul>
      <li><a href="#nfa-引擎表达式主导" id="markdown-toc-nfa-引擎表达式主导">NFA 引擎：表达式主导</a></li>
      <li><a href="#dfa-引擎文本主导" id="markdown-toc-dfa-引擎文本主导">DFA 引擎：文本主导</a></li>
    </ul>
  </li>
  <li><a href="#回溯" id="markdown-toc-回溯">回溯</a>    <ul>
      <li><a href="#回溯的两个要点" id="markdown-toc-回溯的两个要点">回溯的两个要点</a></li>
    </ul>
  </li>
  <li><a href="#关于匹配优先和回溯的更多内容" id="markdown-toc-关于匹配优先和回溯的更多内容">关于匹配优先和回溯的更多内容</a>    <ul>
      <li><a href="#匹配优先的问题" id="markdown-toc-匹配优先的问题">匹配优先的问题</a></li>
      <li><a href="#使用忽略优先量词" id="markdown-toc-使用忽略优先量词">使用忽略优先量词</a></li>
      <li><a href="#占有优先量词---mn" id="markdown-toc-占有优先量词---mn">占有优先量词，?+ *+ ++ {m,n}+</a></li>
      <li><a href="#环视中的回溯" id="markdown-toc-环视中的回溯">环视中的回溯</a></li>
      <li><a href="#多选结构" id="markdown-toc-多选结构">多选结构</a></li>
    </ul>
  </li>
  <li><a href="#nfadfa和posix" id="markdown-toc-nfadfa和posix">NFA、DFA和POSIX</a>    <ul>
      <li><a href="#最左最长规则" id="markdown-toc-最左最长规则">最左最长规则</a></li>
    </ul>
  </li>
</ul>

<h3 id="正则引擎的分类">正则引擎的分类</h3>

<ul>
  <li>
    <p>DFA：确定型有穷自动机
  awk egrep flex lex MySQL Procmail</p>
  </li>
  <li>
    <p>NFA：非确定型有穷自动机</p>

    <ul>
      <li>
        <p>传统型NFA：GNU Emacs、Java grep less more .NET Per PHP Pthon Ruby sed vi</p>
      </li>
      <li>
        <p>POSIX NFA: mawk GNU Emacs</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="匹配的基础">匹配的基础</h3>

<h4 id="规则1优先选择最左端的匹配结果">规则1：优先选择最左端的匹配结果</h4>

<hr />

<p>引擎的构造</p>

<ul>
  <li>文字文本</li>
  <li>字符组、点号、Unicode属性及其他</li>
  <li>捕获型括号</li>
  <li>锚点</li>
</ul>

<hr />

<h4 id="规则2-标准量词是匹配优先">规则2: 标准量词是匹配优先</h4>

<ul>
  <li>标准匹配量词：? * + {min,max} 都是匹配优先</li>
</ul>

<h3 id="表达式主导与文本主导">表达式主导与文本主导</h3>

<ul>
  <li>
    <h4 id="nfa-引擎表达式主导">NFA 引擎：表达式主导</h4>
  </li>
  <li>
    <h4 id="dfa-引擎文本主导">DFA 引擎：文本主导</h4>
  </li>
</ul>

<h3 id="回溯">回溯</h3>

<p><strong>NFA 引擎最重要的性质:</strong> 依次处理各个子表达式或组成元素，遇到需要在两个可能成功的可能中进行选择的时候，它发会选择其一，同时记住另一个，以备稍后可能的需要。</p>

<p><strong>需要做出选择的情形包括量词（决定是否尝试另一次匹配）和多选结构（决定选择哪个多选分支，留下哪个稍后尝试）。</strong></p>

<h4 id="回溯的两个要点">回溯的两个要点</h4>

<ul>
  <li>
    <p>面对众多选择时，哪个分支应当首先选择？</p>

    <p><strong>如果需要在“进行尝试”和“跳过尝试”之间选择，对于匹配优先量词，引擎会优先选择“进行尝试”，而对于忽略优先量词，会选择“跳过尝试”。</strong></p>
  </li>
  <li>
    <p>回溯时使用的是哪个之前保存的分支？
  <strong>距离当前最近储存的选项就是当本地失败强制回溯时返回的。使用的原则是LIFO（last in first out，后进先出）。</strong></p>
  </li>
</ul>

<h3 id="关于匹配优先和回溯的更多内容">关于匹配优先和回溯的更多内容</h3>

<h4 id="匹配优先的问题">匹配优先的问题</h4>

<p>匹配“McDonald’s”？</p>

<div class="highlighter-rouge"><pre class="highlight"><code>**关键：我们希望匹配的不是双引号之间的“任何文本”，而是“除双引号以外的任何文本”。

用` "[^"]*" `取代` ".*" `
</code></pre>
</div>

<h4 id="使用忽略优先量词">使用忽略优先量词</h4>

<ul>
  <li>？？</li>
  <li>*？</li>
  <li>…</li>
  <li>排除环视</li>
</ul>

<p>####　匹配优先、忽略优先和回溯的要旨</p>

<ul>
  <li>
    <p>无论是匹配优先还是忽略优先，只要引擎报告匹配失败，它就必然尝试了所有的可能。</p>
  </li>
  <li>
    <p>匹配优先和忽略优先都不会影响需要检测路径的本身，而只会影响检测的顺序。</p>
  </li>
</ul>

<p>####　占有优先量词和固化分组</p>

<ul>
  <li>
    <p>用（？〉…）实现固化分组</p>

    <p>固化分组的要旨：固化分组会放弃某些可能的路径。</p>
  </li>
</ul>

<h4 id="占有优先量词---mn">占有优先量词，?+ *+ ++ {m,n}+</h4>

<h4 id="环视中的回溯">环视中的回溯</h4>

<p>环视分为4种：肯定型、否定型、顺序环视与逆序环视</p>

<h4 id="多选结构">多选结构</h4>

<p><strong>多选结构既不是匹配优先的，也不是忽略优先的，而是按顺序排列的。</strong></p>

<h3 id="nfadfa和posix">NFA、DFA和POSIX</h3>

<h4 id="最左最长规则">最左最长规则</h4>

