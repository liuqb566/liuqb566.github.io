---
layout: post
title: 正规表示法与文件格式化处理
date: 2016-12-07
categories: Linux
tag: 文本处理
---

* content
{:toc}


***
正规表示法与通配符是完全不一样的东西！  
通配符 (wildcard) 代表的是 bash 操作接口的一个功能  
正规表示法则是一种字符串处理的表示方式  
***

### 语系对正规表示法的影响

由于不同语系的编码数据并不相同，所以就会造成数据撷取结果的差异了。

由于一般我们在练习正规表示法时，使用的是兼容于 POSIX 的标准，因此就使用『C 』这个语系。 因此，底下的很多练习都是使用『LANG=C 』这个语系数据来进行的。

为了要避免这样编码所造成的英文与数字的撷取问题，因此有些特殊的符号我们得要了解一下。

>
- [:alnum:] 代表英文大小写字符及数字，亦即  0-9,A-Z,a-z
- [:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z
- [:blank:] 代表空格键与 [Tab] 按键两者
- [:cntrl:] 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等
- [:digit:] 代表数字而已，亦即 0-9
- [:graph:] 除了空格符 (空格键与 [Tab] 按键) 外的其他所有按键
- [:lower:] 代表小写字符，亦即 a-z
- [:print:] 代表任何可以被打印出来的字符
- [:punct:] 代表标点符号 (punctuation symbol)，亦即：" ' ? ! ; : # $...
- [:upper:] 代表大写字符，亦即 A-Z
- [:space:] 任何会产生空白的字符，包括空格键, [Tab], CR 等等
- [:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字符

### grep 的一些进阶选项

```
[root@www ~]# grep [-A] [-B] [--color=auto] '搜寻字符串' filename
选项与参数：
-A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；
-B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来；
--color=auto 可将正确的那个撷取数据列出颜色
``` 

### 基础正规表示法练习

底下的练习大前提是：

- 语系已经使用`export LANG=C `的设定值；
- `grep`已经使用`alias`设定成为`grep --color=auto `

练习文档：    

- 下载连结：
`http://linux.vbird.org/linux_basic/0330regularex/regular_express.txt`
- 如果你的 Linux 可以直接连上 Internet 的话，那么使用如下的指令来捉取即可：
`wget http://linux.vbird.org/linux_basic/0330regularex/regular_express.txt`

### 基础正规表示法字符汇整 (characters)

- ^word

意义：待搜寻的字符串(word)在行首！

范例：搜寻行首为 # 开始的那一行，并列出行号
`grep -n '^#' regular_express.txt`
- word$

意义：待搜寻的字符串(word)在行尾！

范例：将行尾为 ! 的那一行打印出来，并列出行号
`grep -n '!$' regular_express.txt`
- .

意义：代表『一定有一个任意字符』的字符！

范例：搜寻的字符串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e
与 e 中间『一定』仅有一个字符，而空格符也是字符！
`grep -n 'e.e' regular_express.txt`
- \

意义：跳脱字符，将特殊符号的特殊意义去除！

范例：搜寻含有单引号 ' 的那一行！
`grep -n \' regular_express.txt`
- *

意义：重复零个到无穷多个的前一个 RE 字符

范例：找出含有 (es) (ess) (esss) 等等的字符串，注意，因为 * 可以是 0 个，所以es 也是符合带搜寻字符串。另外，因为 * 为重复『前一个 RE 字符』的符号， 因
此，在 * 之前必须要紧接着一个 RE 字符喔！例如任意字符则为 『 .*』 ！
`grep -n 'ess*' regular_express.txt`
- [list]

意义：字符集合的 RE 字符，里面列出想要撷取的字符！

范例：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中『谨代表一
个待搜寻的字符』， 例如『a[afl]y 』代表搜寻的字符串可以是 aay, afy, aly 即
[afl] 代表 a 或 f 或 l 的意思！
`grep -n 'g[ld]' regular_express.txt`
- [n1-n2]

意义：字符集合的 RE 字符，里面列出想要撷取的字符范围！

范例：搜寻含有任意数字的那一行！需特别留意，在字符集合 [] 中的减号 - 是有
特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码
有关，因此，你的编码需要设定正确(在 bash 当中，需要确定 LANG 与
LANGUAGE 的变量是否正确！) 例如所有大写字符则为 [A-Z]
`grep -n '[0-9]' regular_express.txt`
- [^list]

意义：字符集合的 RE 字符，里面列出不要的字符串或范围！

范例：搜寻的字符串可以是 (oog) (ood) 但不能是 (oot) ，那个 ^ 在 [] 内时，代
表的意义是『反向选择』的意思。 例如，我不要大写字符，则为 [^A-Z]。但是，
需要特别注意的是，如果以```grep -n [^A-Z] regular_express.txt```来搜寻，却发现该档案内的所有行都被列出，为什么？因为这个 [^A-Z] 是『非大写字符』的意
思， 因为每一行均有非大写字符，例如第一行的 "Open Source" 就有 p,e,n,o....
等等的小写字
```grep -n 'oo[^t]' regular_express.txt```
- \{n,m\}

意义：连续 n 到 m 个的『前一个 RE 字符』

意义：若为 \{n\} 则是连续 n 个的前一个 RE 字符，

意义：若是 \{n,\} 则是连续 n 个以上的前一个 RE 字符！ 范例：在 g 与 g 之间有
2 个到 3 个的 o 存在的字符串，亦即 (goog)(gooog)
```grep -n 'go\{2,3\}g' regular_express.txt```

***
『 正规表示法的特殊字符』与一般在指令列输入指令的『通配符』并不相同， 例如，在通配符当中的 * 代表的是『0 ~ 无限多个字符』的意思，但是在正规表示法当中， * 则是『重复 0 到无穷多个的前一个 RE 字符』

举例来说，不支持正规表示法的 ls 这个工具中，若我们使用 ` ls -l * ` 代表的是任意档名的档案，而` ls -l a* `代表的是以 a 为开头的任何档名的档案， 但在正规表示法中，我们要找到含有以 a 为开头的档案，则必须要这样：(需搭配支持正规表示法的工具):
```ls | grep -n '^a.*'```
***

### sed 工具

sed 本身也是一个管线命令，可以分析 standard input 的啦！ 而且 sed 还可以将数据进行取代、删除、新增、撷取特定行等等的功能。

```
[root@www ~]# sed [-nefr] [动作]
选项与参数：
-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行(或者动作)才会被列出来。
-e ：直接在指令列模式上进行 sed 的动作编辑；
-f ：直接将 sed 的动作写在一个档案内， `-f filename`则可以执行 filename 内 的 sed 动作；
-r ：sed 的动作支持的是延伸型正规表示法的语法。 (预设是基础正规表示法语法)
-i ：直接修改读取的档案内容，而不是由屏幕输出。
```
```
动作说明： [n1[,n2]]function
n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『10,20[动作行为] 』
function 有底下这些咚咚：
a ：新增， a 的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)～
c ：取代， c 的后面可以接字符串，这些字符串可以取代 n1,n2 之间的行！
d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
i ：插入，i 的后面可以接字符串，而这些字符串会在新的一行出现(目前的上一行)；
p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运作～
s ：取代，可以直接进行取代的工作！通常这个 s 的动作可以搭配正规表示法！例如 `1,20s/old/new/g`！
```

- 以行为单位的新增/删除功能

```
范例一：将 /etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删
除！
[root@www ~]# nl /etc/passwd | sed '2,5d'
1 root:x:0:0:root:/root:/bin/bash
6 sync:x:5:0:sync:/sbin:/bin/sync
7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
```

**注意**，原本应该是要下达`sed -e`才对，没有`-e`也行！同时也要注意的是，sed后面接的动作，要以`''`两个单引号括住！但是，sed后面如果要接超过**两个**以上的动作时，每个动作前面得加`-e`才行


```
范例二：承上题，在第二行后(亦即是加在第三行)加上『 drink tea?』字样！
[root@www ~]# nl /etc/passwd | sed '2a drink tea'
1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin
drink tea
3 daemon:x:2:2:daemon:/sbin:/sbin/nologin
```
```
范例三：在第二行后面加入两行字，例如『 Drink tea or .....』与『 drink
beer?』
[root@www ~]# nl /etc/passwd | sed '2a Drink tea or ......\ drink beer ?'
```
重点是可以新增**不只一行**！但是每一行之间都必须要以**反斜杠**`\`来进行新行的增加。

- 以行为单位的取代与显示功能

```
范例四：我想将第 2-5 行的内容取代成为『 No 2-5 number』呢？
[root@www ~]# nl /etc/passwd | sed '2,5c No 2-5 number'
```
```
范例五：仅列出 /etc/passwd 档案内的第 5-7 行
[root@www ~]# nl /etc/passwd | sed -n '5,7p'
```
**注意：**`- n`

- 部分数据的搜寻并取代的功能

除了整行的处理模式之外，sed 还可以用行为单位进行部分数据的搜寻并取代的功能。

`sed 's/要被取代的字符串/新的字符串/g`


- 直接修改档案内容(危险动作)

```
范例六：利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !
[root@www ~]# sed -i 's/\.$/\!/g' regular_express.txt
# 上头的 -i 选项可以让你的 sed 直接去修改后面接的档案内容而不是由屏幕输出
```

### 延伸正规表示法

符合正则表达式的NFA流派。

### 文件的格式化与相关处理

#### 格式化打印： printf

```
[root@www ~]# printf '打印格式' 实际内容
选项与参数：
关于格式方面的几个特殊样式：
\a 警告声音输出
\b 退格键(backspace)
\f 清除屏幕 (form feed)
\n 输出新的一行
\r 亦即 Enter 按键
\t 水平的 [tab] 按键
\v 垂直的 [tab] 按键
\xNN NN 为两位数的数字，可以转换数字成为字符。
```

### awk：好用的数据处理工具

相较于 sed 常常作用于**一整个行**的处理，awk 则比较倾向于一行当中分成数个*字段**来处理。默认的『字段的分隔符为**空格键**或 **[tab]键**因此，awk 相当的适合处理**小型的数据**处理。

模式：
` [root@www ~]# awk '条件类型 1{动作 1} 条件类型 2{动作 2} ...' filename `

```
 # 取出账号与登入者的 IP ，且账号与 IP 之间以 [tab] 隔开
[root@www ~]# last -n 5 | awk '{print $1 "\t" $3}'
```

上表是 awk 最常使用的动作**透过 print 的功能将字段数据列出来**,字段的分隔则以空格键或 [tab] 按键来隔开。 因为不论哪一行我都要处理，因此，就不需要有** "条件类型"** 的限制！

使用 awk 的时候，请先确认一下你的数据当中，如果是连续性的数据，请不要有空格或 [tab] 在内，否则，就会发生误判！

- **awk 的处理流程：**
> 1. 读入第一行，并将第一行的资料填入 $0, $1, $2.... 等变数当中；  
2. 依据 "条件类型" 的限制，判断是否需要进行后面的 "动作"；  
3. 做完所有的动作与条件类型；  
4. 若还有后续的『行』的数据，则重复上面1~3的步骤，直到所有的数据都读完为止。

- awk 的内建变量：
> NF 每一行 ($0) 拥有的字段总数  
NR 目前 awk 所处理的是『第几行』数据  
FS 目前的分隔字符，默认是空格键

***
**Tips:**
要注意，awk 后续的所有动作是以单引号`'`括住的，由于单引号与双引号都必须是成对的， 所以， awk 的格式内容如果想要以 print 打印时，记得非变量的文字部分，包含上一小节 printf 提到的格式中，都需要使用**双引号**来定义出来喔！因为单引号已经是 awk 的指令固定用法了！
***

以上面 last -n 5 的例子来做说明，如果我想要：
- 列出每一行的账号(就是`$1`)；
- 列出目前处理的行数(就是 awk 内的`NR`变量)
- 并且说明，该行有多少字段(就是 awk 内的`NF`变量)则可以这样
```
[root@www ~]# last -n 5| awk '{print $1 "\t lines: " NR "\t columes: " NF}'
root lines: 1 columes: 10
```

#### awk 的逻辑运算字符

举例：在`/etc/passwd`当中是以冒号 `:` 来作为字段的分隔， 该档案中第一字段为账号，第三字段则是 UID。那假设我要查阅，第三栏小于 10 以下的数据，并且仅列出账号与第三栏， 那么可以这样做：
```
[root@www ~]# cat /etc/passwd | \
> awk 'BEGIN {FS=":"} $3 < 10 {print $1 "\t " $3}'
```
` BEGIN`:预先设定 awk 的变量,否则FS从**第二行**才能生效。

- awk 来进行计算功能

```
例子：pay.txt
Name 1st 2nd 3th
VBird 23000 24000 25000
DMTsai 21000 20000 23000
Bird2 43000 42000 41000
```

计算每个人的总额并且格式化输出：

- 第一行只是说明，所以第一行不要进行加总 (`NR==1`时处理)；
- 第二行以后就会有加总的情况出现 (`NR>=2`以后处理)
```
[root@www ~]# cat pay.txt | \
> awk 'NR==1{printf
"%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }
NR>=2{total = $2 + $3 + $4
printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'
Name 1st 2nd 3th Total
VBird 23000 24000 25000 72000.00
DMTsai 21000 20000 23000 64000.00
Bird2 43000 42000 41000 126000.00
```

几个重要事项应该要先说明的：
- awk 的指令间隔：所有 awk 的动作，亦即在`{}`内的动作，如果有需要多个指令辅助时，可利用分号` ;`间隔， 或者直接以 `Enter` 按键来隔开每个指令，例如上面的范例中，鸟哥共按了三次`enter` ！
- 逻辑运算当中，如果是『等于』的情况，则务必使用两个等号` ==`！
- 格式化输出时，在`printf`的格式设定当中，务必加上`\n`，才能进行分行！
- 与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上`$`符号。

#### 档案比对工具

- diff

diff 就是用在比对两个档案之间的差异的，并且是以行为单位来比对的！一般是用在 ASCII 纯文本档的比对上。 由于是以行为比对的单位，因此 diff 通常是用在同一的档案(或软件)的新旧版本差异上！

```
[root@www ~]# diff [-bBi] from-file to-file
选项与参数：
from-file ：一个档名，作为原始比对档案的档名；
to-file ：一个档名，作为目的比对档案的档名；
注意，from-file 或 to-file 可以 - 取代，那个 - 代表『 Standard input』之意。
-b ：忽略一行当中，仅有多个空白的差异(例如 "about me" 与 "about me"视为相同
-B ：忽略空白行的差异。
-i ：忽略大小写的不同。
```
#### cmp

mp 主要也是在比对两个档案，他主要利用**字节**单位去比对， 因此，当然也可以比对**binary file**。注意， diff 主要是以**行**为单位比对， cmp 则是以**字节**为单位去比对，这并不相同！

```
[root@www ~]# cmp [-s] file1 file2
选项与参数：
-s ：将所有的不同点的字节处都列出来。因为 cmp 预设仅会输出第一个发现的不同点。
```

#### patch

```
[root@www ~]# patch -pN < patch_file <==更新
[root@www ~]# patch -R -pN < patch_file <==还原
选项与参数：
-p ：后面可以接『取消几层目录』的意思。
-R ：代表还原，将新的文件还原成原来旧的版本。
```

#### 档案打印准备：pr
