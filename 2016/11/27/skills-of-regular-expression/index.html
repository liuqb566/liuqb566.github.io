
<hr />
<p>layout: post
title: 正则表达式的平衡法则
categories: 文本编辑
tag：正则表达式
—</p>

<ul id="markdown-toc">
  <li><a href="#正则表达式的平衡法则" id="markdown-toc-正则表达式的平衡法则">正则表达式的平衡法则</a>    <ul>
      <li><a href="#匹配ip地址" id="markdown-toc-匹配ip地址">匹配IP地址</a></li>
      <li><a href="#处理文件名" id="markdown-toc-处理文件名">处理文件名</a></li>
      <li><a href="#匹配对称的括号" id="markdown-toc-匹配对称的括号">匹配对称的括号</a></li>
      <li><a href="#匹配分隔符之内的文本" id="markdown-toc-匹配分隔符之内的文本">匹配分隔符之内的文本</a></li>
      <li><a href="#容许引文字符串中出现转义引号" id="markdown-toc-容许引文字符串中出现转义引号">容许引文字符串中出现转义引号</a></li>
      <li><a href="#去除文本首尾的空白字符" id="markdown-toc-去除文本首尾的空白字符">去除文本首尾的空白字符</a></li>
    </ul>
  </li>
</ul>

<h3 id="正则表达式的平衡法则">正则表达式的平衡法则</h3>

<p><strong>好的正则表达式必须在以下方面求得平衡:</strong></p>

<ul>
  <li>只匹配期望的文本，排除不期望的文本。</li>
  <li>必须易于控制和理解。</li>
  <li>如果使用NFA引擎，必须保证效率（如果能够匹配，必须很快地返回匹配结果，如果不能匹配，应该在尽可能短的时间内报告匹配失败。）</li>
</ul>

<h4 id="匹配ip地址">匹配IP地址</h4>

<p><strong>对于NFA引擎：应选择尽可能少的分支，以保证效率</strong></p>

<h4 id="处理文件名">处理文件名</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>eg. /usr/local/bin/perl
</code></pre>
</div>

<ul>
  <li>
    <p>去掉文件名开头的路径</p>

    <p>Perl ` $f =~ s{^.*/}{} `</p>
  </li>
  <li>
    <p>从路径中获取文件名</p>

    <p><code class="highlighter-rouge"> [^/]*$ </code> （<em>这个表达式的不足之处在于：它在锚定到最后之间，会进行非常多的回溯</em>）</p>
  </li>
  <li>
    <p>所在路径和文件名</p>

    <p><code class="highlighter-rouge"> ^(.*)/([^/]*$ </code> （<em>这个表达式的不足之处在于：无法匹配不包含路径的文件名，如：file.txt</em>）</p>
  </li>
</ul>

<h4 id="匹配对称的括号">匹配对称的括号</h4>

<hr />

<p><code class="highlighter-rouge"> .* </code> 通常不是合适的选择，因为它非常可能会匹配过多的内容。</p>

<hr />

<h4 id="匹配分隔符之内的文本">匹配分隔符之内的文本</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>1. 匹配起始分隔符
2. 匹配正文
3. 匹配结束分隔符
</code></pre>
</div>

<h4 id="容许引文字符串中出现转义引号">容许引文字符串中出现转义引号</h4>

<p>没看懂</p>

<h4 id="去除文本首尾的空白字符">去除文本首尾的空白字符</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>```
1. s/^\s+//;
2. s/\s+$//;

```
</code></pre>
</div>

